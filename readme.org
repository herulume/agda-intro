#+OPTIONS: num:nil toc:nil

#+REVEAL_TRANS: linear
#+REVEAL_THEME: serif
#+REVEAL_TITLE_SLIDE: <h1>%t</h1>
#+REVEAL_TITLE_SLIDE: <h2>%s</h2>
#+REVEAL_TITLE_SLIDE: <h4>By: %a</h4>

#+Title: Agda
#+Subtitle: Types of types of types of types...
#+Author: @herulume

* whoami
  * Eduardo Jorge Barbosa
  * Masters Student
  * Effectful component-based programming: the case of time
** Where does Agda fit in?
   #+ATTR_HTML: :height 50%, :width 50%
   [[file:./images/agda.png]]
** Where does Agda fit in?
+ Formalize proofs
#+BEGIN_SRC haskell
andAssociative : âˆ€ a b c â†’ (a âˆ§ b) âˆ§ c â‰¡ a âˆ§ (b âˆ§ c)
andAssociative false b c = refl
andAssociative true b c = refl
#+END_SRC
+ Formalize concepts
#+BEGIN_SRC haskell
record Semigroup (a : Set) : Set where
  field
    _âŠ›_ : a â†’ a â†’ a
    associative : âˆ€ a b c â†’ (a âŠ› b) âŠ› c â‰¡ a âŠ› (b âŠ› c)

andSemigroup : Semigroup Bool
andSemigroup = record
  { _âŠ›_ = _âˆ§_
  ; associative = andAssociative
  }
#+END_SRC

#+BEGIN_NOTES
Compare with Haskell's syntax (: vs ::, unicode, laws in the records, no typeclasses)
#+END_NOTES

* *Types*, in programming languages, are *propositions*, in intuitionistic logic, and *objects* of a cartesian closed category.
** Types as propositions, programs as proofs
+ Curry-Howard isomorphism
+ Curry-Howard-Lambek correspondence
** Types as propositions, programs as proofs
+ Types = Propositions
+ Programs = Proofs

* Why not Haskell?
** Haskell's type system
Corresponds to propositional logic
** Is inconsistent as a logic
#+BEGIN_SRC haskell
f :: a -> b
f = undefined
#+END_SRC
** Functions can be non-terminating
#+BEGIN_SRC haskell
let f = f
#+END_SRC

* Agda introduction
Agda is a *dependently typed* language with *pure, total functions*.

#+BEGIN_NOTES
Functions in Agda area like functions in mathematics.
#+END_NOTES
** Meaning
+ Pure functions :: The same inputs yield the same outputs (no side effects)
** Meaning
+ Total :: Functions must terminate and be defined for every possible input

#+BEGIN_SRC haskell
-- Brilliant example by Conor McBride
brexit : âŠ¥
brexit = brexit
#+END_SRC

#+BEGIN_NOTES
Termination matters for proofs.
#+END_NOTES
** Meaning
+ Dependently typed :: Types may depend on values

#+BEGIN_SRC haskell
+-identityÊ³ : âˆ€ (m : â„•) â†’ m + zero â‰¡ m
#+END_SRC

* Syntax
** Set
The type of all boring types
+ Haskell's * (or TYPE)

#+BEGIN_SRC haskell
Bool : Set
Nat : Set
List Bool : Set
#+END_SRC
** Inductive types
#+BEGIN_SRC haskell
data Nat : Set where
  zero : Nat
  suc  : Nat â†’ Nat
#+END_SRC
+ GADTs in Haskell

#+BEGIN_SRC haskell
  {-# BUILTIN NATURAL Nat #-}
#+END_SRC
+ User decimal numbers
** A simple function
#+BEGIN_SRC haskell
Ã—-comm : (A B : Set) â†’ (A Ã— B) â†’ (B Ã— A)
Ã—-comm A B (a , b) = (b , a)
#+END_SRC
+ Named arguments!
** Postulate
#+BEGIN_SRC haskell
postulate A B : Set

Ã—-comm : (A Ã— B) â†’ (B Ã— A)
Ã—-comm (a , b) = (b , a)
#+END_SRC

#+BEGIN_NOTES
Coq style
#+END_NOTES
** Implicit arguments
#+BEGIN_SRC haskell
singleton : {A : Set} â†’ A â†’ List A

singleton true
singleton {ğ”¹} true
#+END_SRC
** Infix notation
#+BEGIN_SRC haskell
_+_ : Nat â†’ Nat â†’ Nat
zero  + m = m
suc n + m = suc (n + m)

 3 + 4
 3 +_
#+END_SRC

#+BEGIN_SRC haskell
if_then_else_ : {A : Set} â†’ Bool â†’ A â†’ A â†’ A
if true then x else y = x
if false then x else y = y
#+END_SRC
** Records
#+BEGIN_SRC haskell
record Pair (A B : Set) : Set where
  constructor _,_
  field
    fst : A
    snd : B

make-pair : {A B : Set} â†’ A â†’ B â†’ Pair A B
make-pair a b = record { fst = a ; snd = b }

-- make-pair : {A B : Set} â†’ A â†’ B â†’ Pair A B
-- make-pair a b = a , b

projâ‚ : {A B : Set} â†’ Pair A B â†’ A
projâ‚ p = Pair.fst p

-- projâ‚ : {A B : Set} â†’ Pair A B â†’ A
-- projâ‚ record { fst = a } = p
#+END_SRC
** Co-pattern matching
#+BEGIN_SRC haskell
p23 : Pair Nat Nat
p23 = record { fst = 2; snd = 3 }

p23 : Pair Nat Nat
Pair.fst p23 = 2
Pair.snd p23 = 3
#+END_SRC
** Co-pattern and pattern matching
#+BEGIN_SRC haskell
record Pair (A B : Set) : Set where
  field
    fst : A
    snd : B

make-pair : {A : Set} â†’ â„• â†’ A â†’ Pair â„• A
Pair.fst (make-pair 0 _) = 4
Pair.fst (make-pair (suc x) _) = x
Pair.snd (make-pair _ y) = y
#+END_SRC
** Many useful concepts...
+ Co-induction
+ Reflection
+ Rewritting

* Dependent types
Types may depend on values!
** Type checking
+ Values are allowed in dependent types
+ Equality of dependent types may require computations
+ Deciding type equality may involve deciding whether two arbitrary programs produce the same result
+ Type checking can be undecidable!
** It's decidable in Agda
+ Force all programs to terminate
** Back to the good stuff
** First-order logic, quantifiers and oh my
** Logic
+ First-order predicate logic extends propositional logic
+ Propositions may *depend* on terms
+ Can be used to formalize the axioms of set theory
** Existential quantifier (Î£-type)
Dependent products
#+BEGIN_SRC haskell
data Î£ (A : Set) (B : A â†’ Set) : Set where
  âŸ¨_,_âŸ© : (x : A) â†’ B x â†’ Î£ A B
#+END_SRC
** Universal quantifiers (Î -type)
An Haskell function
#+BEGIN_SRC haskell
a -> b
#+END_SRC
becomes
#+BEGIN_SRC haskell
(x : a) â†’ b
#+END_SRC
** There's already notation but...
#+BEGIN_SRC haskell
data Î  {A : Set} (A : Set) (B : A â†’ Set) : Set where
  Î› : ((a : A) â†’ B a) â†’ Î  A B
#+END_SRC

* Quintessential example
** Vector
#+BEGIN_SRC haskell
data Vec (A : Set) : Nat â†’ Set where
  []  : Vec A zero
  _âˆ·_ : {n : Nat} â†’ A â†’ Vec A n â†’ Vec A (suc n)
#+END_SRC
+ Indexed data type
** Dependent pattern matching
#+BEGIN_SRC haskell
head : {n : _} {A : Set} â†’ Vec A (suc n) â†’ A
head (x âˆ· _) = x
#+END_SRC


* Universe levels
** Set
The type of all boring types
+ Haskell's * (or TYPE)

#+BEGIN_SRC haskell
Bool : Set
Nat : Set
List Bool : Set
#+END_SRC
** Russell's paradox
+ The collection of all sets is not itself a set
** This is false
#+BEGIN_SRC haskell
Set : Set
#+END_SRC
** Explicit universe levels to the rescue
#+BEGIN_SRC haskell
Set : Setâ‚
Setâ‚ : Setâ‚‚
Setâ‚‚ : Setâ‚ƒ
...
#+END_SRC
** Universe Polymorphism
#+BEGIN_SRC haskell
data List {n : Level} (A : Set n) : Set n where
  []   : List A
  _::_ : A â†’ List A â†’ List A

List Nat : Set
List Set : Setâ‚
List Setâ‚ : Setâ‚‚
#+END_SRC

* Category Theory!
** A Category
#+BEGIN_SRC haskell
record Category (o â„“ e : Level) : Set (suc (o âŠ” â„“ âŠ” e)) where
  eta-equality
  field
    Obj : Set o
    _â‡’_ : Rel Obj â„“
    _â‰ˆ_ : âˆ€ {A B} â†’ Rel (A â‡’ B) e

    id  : âˆ€ {A} â†’ (A â‡’ A)
    _âˆ˜_ : âˆ€ {A B C} â†’ (B â‡’ C) â†’ (A â‡’ B) â†’ (A â‡’ C)
#+END_SRC
** A Category
#+BEGIN_SRC haskell
assoc : âˆ€ {A B C D} {f : A â‡’ B} {g : B â‡’ C} {h : C â‡’ D}
      â†’ (h âˆ˜ g) âˆ˜ f â‰ˆ h âˆ˜ (g âˆ˜ f)

sym-assoc : âˆ€ {A B C D} {f : A â‡’ B} {g : B â‡’ C} {h : C â‡’ D}
          â†’ h âˆ˜ (g âˆ˜ f) â‰ˆ (h âˆ˜ g) âˆ˜ f
#+END_SRC
** Functor
#+BEGIN_SRC haskell
record Functor (C : Category o â„“ e)
               (D : Category oâ€² â„“â€² eâ€²) : Set ... where
  field
    Fâ‚€ : C.Obj â†’ D.Obj
    Fâ‚ : âˆ€ {A B} (f : C [ A , B ]) â†’ D [ Fâ‚€ A , Fâ‚€ B ]

    identity     : âˆ€ {A} â†’ D [ Fâ‚ (C.id {A}) â‰ˆ D.id ]
    homomorphism : âˆ€ {X Y Z} {f : C [ X , Y ]} {g : C [ Y , Z ]}
                 â†’ D [ Fâ‚ (C [ g âˆ˜ f ]) â‰ˆ D [ Fâ‚ g âˆ˜ Fâ‚ f ] ]
    F-resp-â‰ˆ : âˆ€ {A B} {f g : C [ A , B ]}
             â†’ C [ f â‰ˆ g ]
             â†’ D [ Fâ‚ f â‰ˆ Fâ‚ g ]
#+END_SRC

* Small example
** CP with Agda?
** Some auxiliary definitions
#+BEGIN_SRC haskell
record True : Set where

data _âŠ•_ (A B : Set) : Set where
  inl : A â†’ A âŠ• B
  inr : B â†’ A âŠ• B

data _Ã—_ (A B : Set) : Set where
  _,_ : A â†’ B â†’ A Ã— B

uncurry : {A B C : Set} â†’ (A â†’ B â†’ C) â†’ A Ã— B â†’ C
uncurry f (x , xâ‚) = f x xâ‚

const : {A B : Set} â†’ A â†’ B â†’ A
const x _ = x

-- [_||_] : {A B C : Set} â†’ (A â†’ C) â†’ (B â†’ C) â†’ A âŠ• B â†’ C
[ f || g ] (inl x) = f x
[ f || g ] (inr y) = g y
#+END_SRC
** Polynomial Functors
#+BEGIN_SRC haskell
data Functor : Setâ‚ where
  |Id|  : Functor
  |K|   : Set â†’ Functor
  _|+|_ : Functor â†’ Functor â†’ Functor
  _|*|_ : Functor â†’ Functor â†’ Functor

|1| = |K| True
#+END_SRC
** Polynomial Functors
#+BEGIN_SRC haskell
map : (F : Functor) {X Y : Set} â†’ (X â†’ Y) â†’ [ F ] X â†’ [ F ] Y
map |Id| f x = f x
map (|K| A) f x = x
map (F |+| G) f (inl x) = inl (map F f x)
map (F |+| G) f (inr x) = inr (map G f x)
map (F |*| G) f (x , y) = map F f x , map G f y
#+END_SRC
** Decode function
#+BEGIN_SRC haskell
[_] : Functor â†’ Set â†’ Set
[ |Id| ] X = X
[ |K| A ] X = A
[ F |+| G ] X = [ F ] X âŠ• [ G ] X
[ F |*| G ] X = [ F ] X Ã— [ G ] X
#+END_SRC
** Least fixed point
#+BEGIN_SRC haskell
data Î¼_ (F : Functor) : Set where
  <_> : [ F ] (Î¼ F) â†’ Î¼ F
#+END_SRC
** Lists
#+BEGIN_SRC haskell
ListF = Î» A â†’ |1| |+| (|K| A) |*| |Id|
List = Î» A â†’ Î¼ (ListF A)

nil : {A : Set} â†’ List A
nil = < inl _ >

cons : {A : Set} â†’ A â†’ List A â†’ List A
cons x xs = < inr (x , xs) >
#+END_SRC
** Catamorphisms
#+BEGIN_SRC haskell
cata : (F : Functor) {A : Set} â†’ ([ F ] A â†’ A) â†’ Î¼ F â†’ A
cata F Ï† < x > = Ï† (map F (cata' F Ï†) x)
#+END_SRC
+ Can't verify termination!
** Catamorphisms
#+BEGIN_SRC haskell
mapCata : âˆ€ {X} F G â†’ ([ G ] X â†’ X) â†’ [ F ] (Î¼ G) â†’ [ F ] X
mapCata |Id| G Ï† < x > = Ï† (mapCata G G Ï† x)
mapCata (|K| A) G Ï† x = x
mapCata (F |+| Fâ‚) G Ï† (inl x) = inl (mapCata F G Ï† x)
mapCata (F |+| Fâ‚) G Ï† (inr x) = inr (mapCata Fâ‚ G Ï† x)
mapCata (F |*| Fâ‚) G Ï† (x , xâ‚) =
  mapCata F G Ï† x , mapCata Fâ‚ G Ï† xâ‚

âŸ¨|_|âŸ© : âˆ€ {F : Functor} {A : Set} â†’ ([ F ] A â†’ A) â†’ Î¼ F â†’ A
âŸ¨|_|âŸ© {F} Ï† < x > = Ï† (mapCata F F Ï† x)
#+END_SRC
** Foldr
#+BEGIN_SRC haskell
foldr : {A B : Set} â†’ (A â†’ B â†’ B) â†’ B â†’ List A â†’ B
foldr f acc  = âŸ¨| Ï† |âŸ© where
  Ï† = [ const acc || uncurry f ]
#+END_SRC
** Foldr = id
#+BEGIN_SRC haskell
foldr=id' : âˆ€ {A} â†’ (L : List A) â†’ foldr cons nil L â‰¡ id L
foldr=id' < inl _ > = refl
foldr=id' < inr (x , xs) > with foldr=id xs
foldr=id' < inr (x , < xâ‚ >) > | z =
  cong (Î» r â†’ < inr (x , r) >) z
#+END_SRC
* Thank you!
