#+OPTIONS: num:nil toc:nil

#+REVEAL_TRANS: linear
#+REVEAL_THEME: serif
#+REVEAL_TITLE_SLIDE: <h1>%t</h1>
#+REVEAL_TITLE_SLIDE: <h2>%s</h2>
#+REVEAL_TITLE_SLIDE: <h4>By: %a</h4>

#+Title: Agda
#+Subtitle: Types of types of types of types...
#+Author: @herulume

* whoami
  * Eduardo Jorge Barbosa
  * Masters Student
  * Effectful component-based programming: the case of time
** Where does Agda fit in?
   #+ATTR_HTML: :height 50%, :width 50%
   [[file:./images/agda.png]]
** Where does Agda fit in?
+ Formalize proofs
#+BEGIN_SRC haskell
andAssociative : âˆ€ a b c â†’ (a âˆ§ b) âˆ§ c â‰¡ a âˆ§ (b âˆ§ c)
andAssociative false b c = refl
andAssociative true b c = refl
#+END_SRC
+ Formalize concepts
#+BEGIN_SRC haskell
record Semigroup (a : Set) : Set where
  field
    _âŠ›_ : a â†’ a â†’ a
    associative : âˆ€ a b c â†’ (a âŠ› b) âŠ› c â‰¡ a âŠ› (b âŠ› c)

andSemigroup : Semigroup Bool
andSemigroup = record
  { _âŠ›_ = _âˆ§_
  ; associative = andAssociative
  }
#+END_SRC

#+BEGIN_NOTES
Compare with Haskell's syntax (: vs ::, unicode, laws in the records, no typeclasses)
#+END_NOTES

* *Types*, in programming languages, are *propositions*, in intuitionistic logic, and *objects* of a cartesian closed category.
** Types as propositions, programs as proofs
+ Curry-Howard isomorphism
+ Curry-Howard-Lambek correspondence
** Types as propositions, programs as proofs
+ Types = Propositions
+ Programs = Proofs

* Why not Haskell?
** Haskell's type system
Corresponds to propositional logic
** Is inconsistent as a logic
#+BEGIN_SRC haskell
f :: a -> b
f = undefined
#+END_SRC
** Functions can be non-terminating
#+BEGIN_SRC haskell
let f = f
#+END_SRC

* Agda introduction
Agda is a *dependently typed* language with *pure, total functions*.

#+BEGIN_NOTES
Functions in Agda area like functions in mathematics.
#+END_NOTES
** Meaning
+ Pure functions :: The same inputs yield the same outputs (no side effects)
** Meaning
+ Total :: Functions must terminate and be defined for every possible input

#+BEGIN_SRC haskell
-- Brilliant example by Conor McBride
brexit : âŠ¥
brexit = brexit
#+END_SRC

#+BEGIN_NOTES
Termination matters for proofs.
#+END_NOTES
** Meaning
+ Dependently typed :: Types may depend on values

#+BEGIN_SRC haskell
+-identityÊ³ : âˆ€ (m : â„•) â†’ m + zero â‰¡ m
#+END_SRC

* Universe levels
** Set
The type of all boring types
+ Haskell's * (or TYPE)

#+BEGIN_SRC haskell
Bool : Set
Nat : Set
List Bool : Set
#+END_SRC
** Russell's paradox
+ The collection of all sets is not itself a set
** This is false
#+BEGIN_SRC haskell
Set : Set
#+END_SRC
** Explicit universe levels to the rescue
#+BEGIN_SRC haskell
Set : Setâ‚
Setâ‚ : Setâ‚‚
Setâ‚‚ : Setâ‚ƒ
...
#+END_SRC
** Universe Polymorphism
#+BEGIN_SRC haskell
open import Agda.Primitive

data List {n : Level} (A : Set n) : Set n where
  []   : List A
  _::_ : A â†’ List A â†’ List A

List Nat : Set
List Set : Setâ‚
List Setâ‚ : Setâ‚‚
#+END_SRC


* Syntax
** Set
The type of all boring types
** Inductive types
#+BEGIN_SRC haskell
data Nat : Set where
  zero : Nat
  suc  : Nat â†’ Nat
#+END_SRC
+ GADTs in Haskell

#+BEGIN_SRC haskell
  {-# BUILTIN NATURAL Nat #-}
#+END_SRC
+ User decimal numbers
** A simple function
#+BEGIN_SRC haskell
Ã—-comm : (A B : Set) â†’ (A Ã— B) â†’ (B Ã— A)
Ã—-comm A B (a , b) = (b , a)
#+END_SRC
+ Named arguments!
** Postulate
#+BEGIN_SRC haskell
postulate A B : Set

Ã—-comm : (A Ã— B) â†’ (B Ã— A)
Ã—-comm (a , b) = (b , a)
#+END_SRC

#+BEGIN_NOTES
Coq style
#+END_NOTES
** Implicit arguments
#+BEGIN_SRC haskell
singleton : {A : Set} â†’ A â†’ List A

singleton true
singleton {ð”¹} true
#+END_SRC
** Infix notation
#+BEGIN_SRC haskell
_+_ : Nat â†’ Nat â†’ Nat
zero  + m = m
suc n + m = suc (n + m)

 3 + 4
 3 +_
#+END_SRC

#+BEGIN_SRC haskell
if_then_else_ : {A : Set} â†’ Bool â†’ A â†’ A â†’ A
if true then x else y = x
if false then x else y = y
#+END_SRC
** Records
#+BEGIN_SRC haskell
record Pair (A B : Set) : Set where
  constructor _,_
  field
    fst : A
    snd : B

make-pair : {A B : Set} â†’ A â†’ B â†’ Pair A B
make-pair a b = record { fst = a ; snd = b }

-- make-pair : {A B : Set} â†’ A â†’ B â†’ Pair A B
-- make-pair a b = a , b

projâ‚ : {A B : Set} â†’ Pair A B â†’ A
projâ‚ p = Pair.fst p

-- projâ‚ : {A B : Set} â†’ Pair A B â†’ A
-- projâ‚ record { fst = a } = p
#+END_SRC
** Co-pattern matching
#+BEGIN_SRC haskell
p23 : Pair Nat Nat
p23 = record { fst = 2; snd = 3 }

p34 : Pair Nat Nat
Pair.fst p34 = 3
Pair.snd p34 = 4
#+END_SRC
** Co-pattern and pattern matching
#+BEGIN_SRC haskell
record Pair (A B : Set) : Set where
  field
    fst : A
    snd : B

make-pair : {A : Set} â†’ â„• â†’ A â†’ Pair â„• A
(Pair.fst) (make-pair 0 _) = 4
Pair.fst (make-pair (suc x) _) = x
(Pair.snd) (make-pair _ y) = y
#+END_SRC
** Many useful concepts...
+ Co-induction
+ Reflection
+ Rewritting

* Dependent types
Types may depend on values!
** Type checking
+ Values are allowed in dependent types
+ Equality of dependent types may require computations
+ Deciding type equality may involve deciding whether two arbitrary programs produce the same result
+ Type checking can be undecidable!
** It's decidable in Agda
+ Force all programs to terminate
** Back to the good stuff
** First-order logic, quantifiers and oh my
** Logic
+ First-order predicate logic extends propositional logic
+ Propositions may *depend* on terms
+ Can be used to formalize the axioms of set theory
** Existential quantifier (Î£-type)
Dependent products
#+BEGIN_SRC haskell
data Î£ (A : Set) (B : A â†’ Set) : Set where
  âŸ¨_,_âŸ© : (x : A) â†’ B x â†’ Î£ A B
#+END_SRC
** Universal quantifiers (Î -type)
An Haskell function
#+BEGIN_SRC haskell
a -> b
#+END_SRC
becomes
#+BEGIN_SRC haskell
(x : a) â†’ b
#+END_SRC
** There's already notation but...
#+BEGIN_SRC haskell
data Î  {A : Set} (A : Set) (B : A â†’ Set) : Set where
  Î› : ((a : A) â†’ B a) â†’ Î  A B
#+END_SRC

* Quintessential example
** Vector
#+BEGIN_SRC haskell
data Vec (A : Set) : Nat â†’ Set where
  []  : Vec A zero
  _âˆ·_ : {n : Nat} â†’ A â†’ Vec A n â†’ Vec A (suc n)
#+END_SRC
+ Indexed data type
** Dependent pattern matching
#+BEGIN_SRC haskell
head : {n : _} {A : Set} â†’ Vec A (suc n) â†’ A
head (x âˆ· _) = x
#+END_SRC
