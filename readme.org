#+OPTIONS: num:nil toc:nil

#+REVEAL_TRANS: linear
#+REVEAL_THEME: serif
#+REVEAL_TITLE_SLIDE: <h1>%t</h1>
#+REVEAL_TITLE_SLIDE: <h2>%s</h2>
#+REVEAL_TITLE_SLIDE: <h4>By: %a</h4>

#+Title: Agda
#+Subtitle: Types of types of types of types...
#+Author: @herulume

* whoami
  * Eduardo Jorge Barbosa
  * Masters Student
  * Effectful component-based programming: the case of time
** Where does Agda fit in?
   #+ATTR_HTML: :height 50%, :width 50%
   [[file:./images/agda.png]]
** Where does Agda fit in?
+ Formalize proofs
#+BEGIN_SRC haskell
andAssociative : ∀ a b c → (a ∧ b) ∧ c ≡ a ∧ (b ∧ c)
andAssociative false b c = refl
andAssociative true b c = refl
#+END_SRC
+ Formalize concepts
#+BEGIN_SRC haskell
record Semigroup (a : Set) : Set where
  field
    _⊛_ : a → a → a
    associative : ∀ a b c → (a ⊛ b) ⊛ c ≡ a ⊛ (b ⊛ c)

andSemigroup : Semigroup Bool
andSemigroup = record
  { _⊛_ = _∧_
  ; associative = andAssociative
  }
#+END_SRC

#+BEGIN_NOTES
Compare with Haskell's syntax (: vs ::, unicode, laws in the records, no typeclasses)
#+END_NOTES

* *Types*, in programming languages, are *propositions*, in intuitionistic logic, and *objects* of a cartesian closed category.
** Types as propositions, programs as proofs
+ Curry-Howard isomorphism
+ Curry-Howard-Lambek correspondence
** Types as propositions, programs as proofs
+ Types = Propositions
+ Programs = Proofs

* Why not Haskell?
** Haskell's type system
Corresponds to propositional logic
** Is inconsistent as a logic
#+BEGIN_SRC haskell
f :: a -> b
f = undefined
#+END_SRC
** Functions can be non-terminating
#+BEGIN_SRC haskell
let f = f
#+END_SRC

* Agda introduction
Agda is a *dependently typed* language with *pure, total functions*.

#+BEGIN_NOTES
Functions in Agda area like functions in mathematics.
#+END_NOTES
** Meaning
+ Pure functions :: The same inputs yield the same outputs (no side effects)
** Meaning
+ Total :: Functions must terminate and be defined for every possible input

#+BEGIN_SRC haskell
-- Brilliant example by Conor McBride
brexit : ⊥
brexit = brexit
#+END_SRC

#+BEGIN_NOTES
Termination matters for proofs.
#+END_NOTES
** Meaning
+ Dependently typed :: Types may depend on values

#+BEGIN_SRC haskell
+-identityʳ : ∀ (m : ℕ) → m + zero ≡ m
#+END_SRC

* Universe levels
** Set
The type of all boring types
+ Haskell's * (or TYPE)

#+BEGIN_SRC haskell
Bool : Set
Nat : Set
List Bool : Set
#+END_SRC
** Russell's paradox
+ The collection of all sets is not itself a set
** This is false
#+BEGIN_SRC haskell
Set : Set
#+END_SRC
** Explicit universe levels to the rescue
#+BEGIN_SRC haskell
Set : Set₁
Set₁ : Set₂
Set₂ : Set₃
...
#+END_SRC
** Universe Polymorphism
#+BEGIN_SRC haskell
open import Agda.Primitive

data List {n : Level} (A : Set n) : Set n where
  []   : List A
  _::_ : A → List A → List A

List Nat : Set
List Set : Set₁
List Set₁ : Set₂
#+END_SRC


* Syntax
** Set
The type of all boring types
** Inductive types
#+BEGIN_SRC haskell
data Nat : Set where
  zero : Nat
  suc  : Nat → Nat
#+END_SRC
+ GADTs in Haskell

#+BEGIN_SRC haskell
  {-# BUILTIN NATURAL Nat #-}
#+END_SRC
+ User decimal numbers
** A simple function
#+BEGIN_SRC haskell
×-comm : (A B : Set) → (A × B) → (B × A)
×-comm A B (a , b) = (b , a)
#+END_SRC
+ Named arguments!
** Postulate
#+BEGIN_SRC haskell
postulate A B : Set

×-comm : (A × B) → (B × A)
×-comm (a , b) = (b , a)
#+END_SRC

#+BEGIN_NOTES
Coq style
#+END_NOTES
** Implicit arguments
#+BEGIN_SRC haskell
singleton : {A : Set} → A → List A

singleton true
singleton {𝔹} true
#+END_SRC
** Infix notation
#+BEGIN_SRC haskell
_+_ : Nat → Nat → Nat
zero  + m = m
suc n + m = suc (n + m)

 3 + 4
 3 +_
#+END_SRC

#+BEGIN_SRC haskell
if_then_else_ : {A : Set} → Bool → A → A → A
if true then x else y = x
if false then x else y = y
#+END_SRC
** Records
#+BEGIN_SRC haskell
record Pair (A B : Set) : Set where
  constructor _,_
  field
    fst : A
    snd : B

make-pair : {A B : Set} → A → B → Pair A B
make-pair a b = record { fst = a ; snd = b }

-- make-pair : {A B : Set} → A → B → Pair A B
-- make-pair a b = a , b

proj₁ : {A B : Set} → Pair A B → A
proj₁ p = Pair.fst p

-- proj₁ : {A B : Set} → Pair A B → A
-- proj₁ record { fst = a } = p
#+END_SRC
** Co-pattern matching
#+BEGIN_SRC haskell
p23 : Pair Nat Nat
p23 = record { fst = 2; snd = 3 }

p34 : Pair Nat Nat
Pair.fst p34 = 3
Pair.snd p34 = 4
#+END_SRC
** Co-pattern and pattern matching
#+BEGIN_SRC haskell
record Pair (A B : Set) : Set where
  field
    fst : A
    snd : B

make-pair : {A : Set} → ℕ → A → Pair ℕ A
(Pair.fst) (make-pair 0 _) = 4
Pair.fst (make-pair (suc x) _) = x
(Pair.snd) (make-pair _ y) = y
#+END_SRC
** Many useful concepts...
+ Co-induction
+ Reflection
+ Rewritting

* Dependent types
Types may depend on values!
** Type checking
+ Values are allowed in dependent types
+ Equality of dependent types may require computations
+ Deciding type equality may involve deciding whether two arbitrary programs produce the same result
+ Type checking can be undecidable!
** It's decidable in Agda
+ Force all programs to terminate
** Back to the good stuff
** First-order logic, quantifiers and oh my
** Logic
+ First-order predicate logic extends propositional logic
+ Propositions may *depend* on terms
+ Can be used to formalize the axioms of set theory
** Existential quantifier (Σ-type)
Dependent products
#+BEGIN_SRC haskell
data Σ (A : Set) (B : A → Set) : Set where
  ⟨_,_⟩ : (x : A) → B x → Σ A B
#+END_SRC
** Universal quantifiers (Π-type)
An Haskell function
#+BEGIN_SRC haskell
a -> b
#+END_SRC
becomes
#+BEGIN_SRC haskell
(x : a) → b
#+END_SRC
** There's already notation but...
#+BEGIN_SRC haskell
data Π {A : Set} (A : Set) (B : A → Set) : Set where
  Λ : ((a : A) → B a) → Π A B
#+END_SRC

* Quintessential example
** Vector
#+BEGIN_SRC haskell
data Vec (A : Set) : Nat → Set where
  []  : Vec A zero
  _∷_ : {n : Nat} → A → Vec A n → Vec A (suc n)
#+END_SRC
+ Indexed data type
** Dependent pattern matching
#+BEGIN_SRC haskell
head : {n : _} {A : Set} → Vec A (suc n) → A
head (x ∷ _) = x
#+END_SRC

* Category Theory!
** A Category
#+BEGIN_SRC haskell
record Category (o ℓ e : Level) : Set (suc (o ⊔ ℓ ⊔ e)) where
  eta-equality
  field
    Obj : Set o
    _⇒_ : Rel Obj ℓ
    _≈_ : ∀ {A B} → Rel (A ⇒ B) e

    id  : ∀ {A} → (A ⇒ A)
    _∘_ : ∀ {A B C} → (B ⇒ C) → (A ⇒ B) → (A ⇒ C)
#+END_SRC
** A Category
#+BEGIN_SRC haskell
assoc : ∀ {A B C D} {f : A ⇒ B} {g : B ⇒ C} {h : C ⇒ D}
      → (h ∘ g) ∘ f ≈ h ∘ (g ∘ f)

sym-assoc : ∀ {A B C D} {f : A ⇒ B} {g : B ⇒ C} {h : C ⇒ D}
          → h ∘ (g ∘ f) ≈ (h ∘ g) ∘ f
#+END_SRC
** Functor
#+BEGIN_SRC haskell
record Functor (C : Category o ℓ e)
               (D : Category o′ ℓ′ e′) : Set ... where
  field
    F₀ : C.Obj → D.Obj
    F₁ : ∀ {A B} (f : C [ A , B ]) → D [ F₀ A , F₀ B ]

    identity     : ∀ {A} → D [ F₁ (C.id {A}) ≈ D.id ]
    homomorphism : ∀ {X Y Z} {f : C [ X , Y ]} {g : C [ Y , Z ]}
                 → D [ F₁ (C [ g ∘ f ]) ≈ D [ F₁ g ∘ F₁ f ] ]
    F-resp-≈ : ∀ {A B} {f g : C [ A , B ]}
             → C [ f ≈ g ]
             → D [ F₁ f ≈ F₁ g ]
#+END_SRC

** Duration Monad
#+BEGIN_SRC haskell
natDuration : Monad (Setoids 0ℓ 0ℓ)
natDuration = monoid×-monad +-0-nat-monoid

integerDuration : Monad (Setoids 0ℓ 0ℓ)
integerDuration = monoid×-monad +-0-integer-monoid

rationalDuration-sets : Monad (Setoids 0ℓ 0ℓ)
rationalDuration-sets = monoid×-monad +-0-rational-monoid

Kᴰ : Category (suc 0ℓ) 0ℓ 0ℓ
Kᴰ = Kleisli natDuration
#+END_SRC

* Questions?
